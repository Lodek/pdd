from collections import OrderedDict, defaultdict, deque

class Updater:

    """Implementation of the Observer design pattern. A Bus update notifies
Updater which in turn calls the update method in all Circuit objs. that depend on Bus.
That initiates a cascate of Bus events. Updater job for the cycle is done when
no new events are generated by an update call.

There is a maximum threshold (default 255, change within init)to Updater's number 
of calls per cycle in order to avoid deadlocks caused by improper circuits
(e.g. unstable circuits or circuits with cyclic paths)"""

    def __init__(self, threshold=255):
        self.threshold = threshold
        self.events = []
        self.relations = defaultdict(list)

    def subscribe(self, circuit, buses):
        """Subscribe circuit to buses. Events from a bus in buses cause circuit
to be called upon updating cycle"""
        for bus in buses:
            self.relations[bus].append(circuit)

    def unsubscribe(self, circuit, buses):
        """Remove circuit as a dependent of buses in buses."""
        for bus in buses:
            try:
                self.relations[bus].remove(circuit)
            except ValueError:
                pass

    def notify(self, event):
        """Notifies Updater of new event, adds it to list of events"""
        self.events.append(event)
        
    def handle_events(self):
        """Handle all events in self.events. Events are handled in a FIFO manner
and handling events is likely to cause more events to be generated.

If the number of events in the cycle exceed threshold, raises a Runtime error
with the last 10 circuits handled."""
        last_10 = deque([None]*10, max_len=10)
        for i in range(threshold):
            try:
                event = self.events.pop(0)
                for circuit in self.relations[event.bus]:
                    last_10.appendright(circuit)
                    circuit.update()
            except IndexError:
                break
        error_str = 'Update threshold blew up; check for cyclic path.'
        error = RuntimeError(error_str, last_10)
        raise error

    
class Signal:

    """Signal provies an API to deal with digital signals. The data carried by
a Bus is encoded as a Signal. Signal provides methods to perform logical operations
that takes Signal objects as operands and return a new instace of Signal.
Signal is constructed from an iterable that made of 0 and 1. eg. Signal('0101')"""
    
    def __init__(self, data):
        self.data = [int(d) for d in data]

    def __getitem__(self, index):
        return self.data[index]
    
    def __len__(self):
        return len(self.data)

    def __eq__(self, other):
        return True if self.data == other.data else False

    def __repr__(self):
        return 'Signal({})'.format(self.data)

    def complement(self):
        return Signal.NOT(self)

    @classmethod
    def from_wires(cls, wires):
        data = [w.bit for w in wires]
        return cls(data)
        
    @classmethod
    def NOT(cls, a):
        inv = [1 if v == 0 else 0 for v in a.data]
        return cls(inv)

    @classmethod
    def OR(cls, a, b):
        res = [i|j for i, j, in zip(a.data, b.data)]
        return cls(res)

    @classmethod
    def AND(cls, a, b):
        res = [i&j for i, j, in zip(a.data, b.data)]
        return cls(res)

    @classmethod
    def XOR(cls, a, b):
        res = [i^j for i, j, in zip(a.data, b.data)]
        return cls(res)


class Wire:

    """A Bus has a number of Wires, each Wire carries a bit of data"""
    
    def __init__(self, value=0):
        self.bit = value

    def __repr__(self):
        return 'Wire({})'.format(self.bit)

class Bus:

    """The Bus class is an abstraction for a wire or a group of wires. 
Bus connects Terminals. Bus are made up of Wires therefore they are sliceable,
slicing a Bus returns a new Bus that is associated to the previosu one. Any
changes made to the original Bus propagates to the sliced Bus.
Bus value is given by Signal which gives a higher level API. Two Bus are equal if
their signals are equal"""

    def __init__(self, n=1):
        self.wires = [Wire() for _ in range(n)] 

    def __repr__(self):
        return 'Bus({})'.format(repr(self.signal))

    def __len__(self):
        return len(self.wires)

    def __getitem__(self, index):
        """Creates a new Bus from the sliced wires, returns new Bus"""
        wires = self.wires[index]
        if type(wires) != list:
            wires = [wires]
        return Bus._from_wires(wires)

    def __eq__(self, other):
        return True if self.signal == other.signal else False

    def extend(self, size):
        """Changes size of self to size, new Wires are initialized to 0"""
        nsize = size - len(self)
        if nsize > 0:
            self.wires += [Wire() for _ in range(nsize)]
        else:
            self.wires = self.wires[:size]
        
    @property
    def signal(self):
        """Computes Signal for bus and returns it"""
        return Signal.from_wires(self.wires)
        
    @signal.setter
    def signal(self, value):
        """Constructs a Signal from value and assigns it to self"""
        s = Signal(value)
        if len(s) != len(self):
            raise ValueError('Value has the wrong length')
        for wire, d in zip(self.wires, s.data):
            wire.bit = d

    @classmethod
    def _from_wires(cls, wires):
        bus = Bus(len(wires))
        bus.wires = wires
        return bus
    
GND = Bus()
VDD = Bus()
VDD.signal = '1'
        
class Terminal:

    """Terminals are how circuit blocks interface.
Terminals are conceptually similar to buffers, its input and output are connected
to distinct buses. The terminal reads the input bus' signal and writes 
that same signal to the output bus. It's possible to use a Terminal as a NOT
gate as well, in which case the output would be the logical negation of the input.
The input and output for every circuit Block is a Terminal.
Optionally, it is possible to toggle whether the output propagates the signal
to the bus or not. If self.connected is tied to GND, then the signal will not propagate
this is analogous to being at a High Impedance."""

    def __init__(self, bus_len = -1, connected=VDD, invert=False):
        self._in_bus = None
        self.out_bus = Bus()
        self.invert = invert
        self.connected = connected
        self.bus_len = bus_len

    @property
    def in_bus(self):
        return self._in_bus

    @in_bus.setter
    def in_bus(self, bus):
        if self.bus_len != -1 and len(bus) != self.bus_len:
            raise ValueError("Bus size incompatible with requirements")
        self._in_bus = bus
        l = len(bus)
        self.out_bus.extend(l)
        
    def propagate(self):
        in_sig = self.in_bus.signal
        if self.connected == VDD:
            self.out_bus.signal = in_sig if not self.invert else in_sig.complement()
        

class Circuit:

    """A circuit follows the classical definition from digital logic,
a black box with inputs outputs and a functional specification. 
A Circuit could be a simple AND gate or it could be a full ALU or even processor."""
    
    def __init__(self, inputs, outputs, invert=[]):
        self.invert = invert
        self.circuits = []
        self.labels = {'in':inputs, 'out':outputs}
        self.terminals = {label:Terminal() for label in inputs + outputs}
        self._func_spec()
        for label in self.invert:
            self.terminals[label].invert = True

    def _func_spec():
        pass
    
    def connect(self, dic):
        """Dictionary is of the form {label:bus}, attaches 'bus' to  'label' Terminal's in_bus"""
        for label, bus in dic.items():
            self.terminals[label].in_bus = bus

    def outputs(self, label):
        return self.terminals[label].out_bus
    
    def output(self):
        label = self.labels['out'][0]
        return self.terminals[label].out_bus

    def nodes(self, label):
        """Return Bus associated to internal connection of the Terminal
linked to label"""
        if label in self.labels['in']:
            bus = self.terminals[label].out_bus
        elif label in self.labels['out']:
            bus = self.terminals[label].in_bus
        return bus

    def compute(self):
        for label in self.terminals['in']:
            self.terminals[label].propagate()
        for circuit in self.circuits:
            circuit.compute()
        for label in self.terminals['out']:
            self.terminals[label].propagate()

class Gate(Circuit):

    """Base class for the basic logic gates"""

    _ops = {'and':Signal.AND, 'or':Signal.OR, 'xor':Signal.XOR}
    
    def __init__(self, a, b, operation, invert=[]):
        inputs = 'a b'.split()
        outputs = ['y']
        self.op = self._ops[operation]
        super().__init__(inputs, outputs, invert)

    def _func_spec(self, a_sig, b_sig):
        result = self.op(a_sig, b_sig)
        return result


    def connect(self, dic):
        super().connect(dic)
        b = Bus(len(self.nodes['a']))
        self.connect({'y':b})


    def compute(self):
        for label in self.terminals['in']:
            self.terminals[label].propagate()
        a_sig = self.nodes['a'].signal
        b_sig = self.nodes['b'].signal
        result = self._func_spec(a_sig, b_sig)
        self.nodes['y'].signal = result
        for label in self.terminals['out']:
            self.terminals[label].propagate()



class Inspector:

    """Base class that defines methods which will be called by the singleton """
    pass

class SigGen:

    """A Signal Generator object interacts with a bus and sends signals to it."""
    pass
