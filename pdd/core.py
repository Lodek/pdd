"""Module containg abstractions which are used to implement digital logic. The objects in this module aren't physical entities as much as concepts in digital logic"""

from collections import defaultdict, deque
import logging

logger = logging.getLogger(__name__)

class Wire:
    """
    Wire represents a bit of data.
    """
    def __init__(self, bit=0):
        self.bit = bit

    def __repr__(self):
        s = '{}: bit={};'
        return s.format(self.__class__, self.bit)

 
class Signal:
    """
    Signal abstracts digital signals and is used to set values on a Bus.
    Signal provides an API to deal with digital signals. The data carried by
    a Bus is encoded as a Signal. Signal provides methods to perform logical operations
    that take Signal objects as operands and return a new instace of Signal.
    """
    def __init__(self, value, size):
        if type(value) is int:
            self.value = value
        else:
            msg = 'Argument of type {} to {}. Must be an Integer'
            e = TypeError(msg.format(type(value), self.__class__))
            logger.exception(e)
            raise e
        self.size = size
        logger.debug(repr(self))
        
    def to_bits(self):
        """Return a tuple bitwise representation of Signal. 
        The 0th element of the sequence represents the 0th bit.
        This seemingly odd behavior makes slicing busses easier"""
        return tuple(self.value >> i & 0x1 for i in range(self.size))

    def __len__(self):
        return self.size

    def __eq__(self, other):
        return self.value == other.value

    def __repr__(self):
        s = '{}: value={};'
        return s.format(self.__class__, hex(self.value))
        
    def __str__(self):
        return hex(self.value)

    def complement(self):
        return Signal.NOT(self)
    
    @classmethod
    def NOT(cls, a):
        mask = 0
        for i in range(len(a)):
            mask |= 1 << i
        value = ~a.value & mask
        return cls(value, len(a))

    @classmethod
    def OR(cls, a, b):
        value = a.value | b.value
        return cls(value, len(a))

    @classmethod
    def AND(cls, a, b):
        value = a.value & b.value
        return cls(value, len(a))

    @classmethod
    def XOR(cls, a, b):
        value = a.value ^ b.value
        return cls(value, len(a))

class Updater:
    """
    Implementation of the Observer design pattern.

    A Bus update generates an event and Updater is notified.
    Updater gets called to handle the events which in turn updates circuits.
    Handling events begins a cascate of Bus events. Updater's job for the cycle is done when
    no new events are generated by an update call.

    There is a maximum threshold (default 255, change within init)to Updater's number 
    of calls per cycle in order to avoid deadlocks caused by improper circuits
    (e.g. unstable circuits or circuits with cyclic paths)
    """
    def __init__(self, threshold=2**20):
        logger.info('Updater object created')
        self.threshold = threshold
        self.events = []
        self.relations = defaultdict(list)

    def subscribe(self, circuit, buses):
        """`circuit` is notified of any changes made to bus in `buses`."""
        for bus in buses:
            logger.debug('Subscribed {} to {}'.format(circuit, bus))
            self.relations[id(bus)].append(circuit)

    def unsubscribe(self, circuit, buses):
        """`circuit` is no longer notified when changes are made to bus in ` buses`."""
        for bus in buses:
            try:
                self.relations[id(bus)].remove(circuit)
                logger.debug('Unsubscribed {} from {}'.format(circuit, bus))
            except ValueError:
                pass

    def notify(self, event):
        """Notifies Updater of new event, adds it to list of events"""
        logger.debug('New Updater event: ' + repr(event))
        self.events.append(event)
        
    def handle_events(self):
        """Handle all events from this cycle until list is empty or threshold blows up.

        Handle all events in self.events. Events are handled in a FIFO manner
        and handling events is likely to cause more events to be generated.

        If the number of events in the cycle exceed threshold, raises a Runtime error
        with the last circuits handled.
        """
        logger.info('Handling events')
        deque_len = 50
        last = deque([None]*deque_len, maxlen=deque_len)
        for i in range(self.threshold):
            try:
                event = self.events.pop(0)
                logger.debug('Handling event {}'.format(event))
                for circuit in self.relations[id(event.bus)]:
                    last.append(circuit)
                    logger.debug('updating circuit {}'.format(circuit))
                    circuit.update()
            except IndexError:
                break
        else:
            error_str = 'Update threshold blew up; check for cyclic path.'
            error = RuntimeError(error_str, last)
            raise error
